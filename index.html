<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Generate by GPT-5.3-Codex" />
    <title>Camera Preview + PiP</title>
    <style>
      :root {
        color-scheme: light;
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        width: 100%;
        height: 100%;
        margin: 0;
        background: #000;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      }

      .app {
        position: relative;
        width: 100vw;
        height: 100vh;
        height: 100dvh;
        overflow: hidden;
      }

      .layer {
        position: absolute;
        inset: 0;
      }

      video {
        width: 100%;
        height: 100%;
        object-fit: contain;
        object-position: center;
        display: block;
        background: #000;
      }

      video.is-mirrored {
        transform: scaleX(-1);
      }

      canvas {
        width: 100%;
        height: 100%;
        display: block;
        background: #000;
      }

      #snapshot {
        display: none;
        pointer-events: none;
      }

      .app.is-snapshot-mode #snapshot {
        display: block;
      }

      .app.is-snapshot-mode #preview {
        opacity: 0;
        pointer-events: none;
      }

      .pip-source {
        position: fixed;
        left: -9999px;
        top: -9999px;
        width: 1px;
        height: 1px;
        opacity: 0;
        pointer-events: none;
      }

      .controls {
        position: absolute;
        right: 16px;
        bottom: 16px;
        display: flex;
        gap: 10px;
        align-items: flex-end;
        z-index: 10;
        flex-wrap: wrap;
        max-width: min(92vw, 520px);
      }

      button {
        border: 0;
        border-radius: 10px;
        padding: 10px 14px;
        font-size: 14px;
        font-weight: 600;
        color: #fff;
        background: rgba(0, 0, 0, 0.55);
        backdrop-filter: blur(6px);
        cursor: pointer;
      }

      button:disabled {
        opacity: 0.45;
        cursor: not-allowed;
      }

      .control-panel {
        display: flex;
        gap: 10px;
        align-items: flex-end;
        padding: 10px 12px;
        border-radius: 10px;
        color: #fff;
        background: rgba(0, 0, 0, 0.55);
        backdrop-filter: blur(6px);
      }

      .field {
        display: flex;
        flex-direction: column;
        gap: 6px;
        font-size: 12px;
        color: rgba(255, 255, 255, 0.86);
        user-select: none;
      }

      input[type='number'] {
        width: 150px;
        padding: 8px 10px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.18);
        background: rgba(0, 0, 0, 0.35);
        color: #fff;
        outline: none;
      }

      .checkbox {
        display: flex;
        gap: 8px;
        align-items: center;
        height: 34px;
        font-size: 12px;
        color: rgba(255, 255, 255, 0.86);
        user-select: none;
      }

      .status {
        position: absolute;
        left: 16px;
        bottom: 16px;
        z-index: 10;
        color: #fff;
        font-size: 13px;
        background: rgba(0, 0, 0, 0.45);
        border-radius: 8px;
        padding: 8px 10px;
      }
    </style>
  </head>
  <body>
    <main class="app">
      <video id="preview" class="layer" autoplay playsinline muted></video>
      <canvas id="snapshot" class="layer" aria-hidden="true"></canvas>
      <video
        id="pipSource"
        class="pip-source"
        autoplay
        playsinline
        muted
        aria-hidden="true"
      ></video>

      <div class="controls">
        <form id="refreshForm" class="control-panel">
          <label class="field">
            刷新间隔 (ms)
            <input
              id="refreshIntervalInput"
              type="number"
              min="0"
              step="1"
              inputmode="numeric"
              placeholder="0 = 实时"
              value="0"
              aria-label="刷新间隔（毫秒）"
            />
          </label>
          <label
            class="checkbox"
            title="开启后每次抓帧会关闭摄像头；适合很长的刷新间隔（例如 10 秒）"
          >
            <input id="releaseAfterCaptureInput" type="checkbox" />
            拍完关闭摄像头
          </label>
          <button id="applyRefreshButton" type="submit">应用</button>
        </form>
        <button id="mirrorButton" type="button">镜像预览: 关 (Space)</button>
        <button id="pipButton" type="button">进入画中画 (Enter)</button>
      </div>

      <div class="status" id="status">初始化中...</div>
    </main>

    <script type="module">
      const State = Object.freeze({
        INIT: 'INIT',
        LOADING: 'LOADING',
        READY: 'READY',
        PIP: 'PIP',
        ERROR: 'ERROR',
      })

      const UiMessage = Object.freeze({
        INIT: '初始化中...',
        LOADING: '正在请求摄像头权限...',
        READY: '摄像头已连接',
        PIP: '已进入画中画',
        HIDDEN_RELEASED: '页面不可见，摄像头已释放',
        NO_MEDIA_DEVICES: '当前浏览器不支持 MediaDevices API',
        INSECURE_CONTEXT: '请在 HTTPS 或 localhost 环境下使用摄像头',
        PERMISSION_DENIED: '用户拒绝了摄像头权限',
        CAMERA_NOT_FOUND: '未检测到可用摄像头',
        CAMERA_BUSY: '摄像头被其他应用占用',
        PIP_NOT_SUPPORTED: '当前浏览器不支持 Picture-in-Picture',
        PIP_NOT_READY: '视频尚未准备好，无法进入画中画',
        CAPTURESTREAM_NOT_SUPPORTED:
          '当前浏览器不支持 Canvas captureStream，无法在定时刷新模式下使用画中画',
        PIP_FAILED: '画中画操作失败，请重试',
        UNKNOWN_ERROR: '发生未知错误，请稍后重试',
      })

      const ErrorCode = Object.freeze({
        NO_MEDIA_DEVICES: 'NO_MEDIA_DEVICES',
        INSECURE_CONTEXT: 'INSECURE_CONTEXT',
        PERMISSION_DENIED: 'PERMISSION_DENIED',
        CAMERA_NOT_FOUND: 'CAMERA_NOT_FOUND',
        CAMERA_BUSY: 'CAMERA_BUSY',
        PIP_NOT_SUPPORTED: 'PIP_NOT_SUPPORTED',
        PIP_NOT_READY: 'PIP_NOT_READY',
        CAPTURESTREAM_NOT_SUPPORTED: 'CAPTURESTREAM_NOT_SUPPORTED',
        PIP_FAILED: 'PIP_FAILED',
        UNKNOWN_ERROR: 'UNKNOWN_ERROR',
      })

      const el = {
        app: document.querySelector('.app'),
        video: document.getElementById('preview'),
        snapshot: document.getElementById('snapshot'),
        pipSource: document.getElementById('pipSource'),
        mirrorButton: document.getElementById('mirrorButton'),
        pipButton: document.getElementById('pipButton'),
        refreshForm: document.getElementById('refreshForm'),
        refreshIntervalInput: document.getElementById('refreshIntervalInput'),
        releaseAfterCaptureInput: document.getElementById('releaseAfterCaptureInput'),
        status: document.getElementById('status'),
      }

      const pipCapabilities = Object.freeze({
        standard:
          typeof HTMLVideoElement.prototype.requestPictureInPicture === 'function' &&
          document.pictureInPictureEnabled !== false,
        webkit:
          typeof HTMLVideoElement.prototype.webkitSupportsPresentationMode === 'function' &&
          typeof HTMLVideoElement.prototype.webkitSetPresentationMode === 'function',
      })

      const stateModel = {
        state: State.INIT,
        reason: null,
        errorCode: null,
        pipSupported: pipCapabilities.standard || pipCapabilities.webkit,
        videoReady: false,
        actionLocked: false,
        previewMirrored: false,
        refreshIntervalMs: 0,
        releaseAfterCapture: true,
        timedRefreshActive: false,
        captureInProgress: false,
        lastCaptureAt: null,
      }

      function setState(nextState, payload = {}) {
        stateModel.state = nextState
        stateModel.reason = payload.reason ?? null
        stateModel.errorCode = payload.errorCode ?? null
        render()
      }

      function setActionLock(locked) {
        stateModel.actionLocked = locked
        render()
      }

      function setVideoReady(ready) {
        stateModel.videoReady = ready
        render()
      }

      function getErrorMessage(errorCode) {
        switch (errorCode) {
          case ErrorCode.NO_MEDIA_DEVICES:
            return UiMessage.NO_MEDIA_DEVICES
          case ErrorCode.INSECURE_CONTEXT:
            return UiMessage.INSECURE_CONTEXT
          case ErrorCode.PERMISSION_DENIED:
            return UiMessage.PERMISSION_DENIED
          case ErrorCode.CAMERA_NOT_FOUND:
            return UiMessage.CAMERA_NOT_FOUND
          case ErrorCode.CAMERA_BUSY:
            return UiMessage.CAMERA_BUSY
          case ErrorCode.PIP_NOT_SUPPORTED:
            return UiMessage.PIP_NOT_SUPPORTED
          case ErrorCode.PIP_NOT_READY:
            return UiMessage.PIP_NOT_READY
          case ErrorCode.CAPTURESTREAM_NOT_SUPPORTED:
            return UiMessage.CAPTURESTREAM_NOT_SUPPORTED
          case ErrorCode.PIP_FAILED:
            return UiMessage.PIP_FAILED
          default:
            return UiMessage.UNKNOWN_ERROR
        }
      }

      function getStatusText() {
        if (stateModel.state === State.ERROR) {
          return getErrorMessage(stateModel.errorCode)
        }

        if (stateModel.state === State.INIT && stateModel.reason === 'HIDDEN_RELEASED') {
          return UiMessage.HIDDEN_RELEASED
        }

        switch (stateModel.state) {
          case State.LOADING:
            return UiMessage.LOADING
          case State.READY:
            return formatStatusWithRefresh(UiMessage.READY)
          case State.PIP:
            return formatStatusWithRefresh(UiMessage.PIP)
          case State.INIT:
          default:
            return formatStatusWithRefresh(UiMessage.INIT)
        }
      }

      function pad2(value) {
        return String(value).padStart(2, '0')
      }

      function formatTime(date) {
        return `${pad2(date.getHours())}:${pad2(date.getMinutes())}:${pad2(date.getSeconds())}`
      }

      function formatStatusWithRefresh(baseText) {
        if (!stateModel.timedRefreshActive || stateModel.refreshIntervalMs <= 0) {
          return baseText
        }

        const parts = [`定时刷新: ${stateModel.refreshIntervalMs}ms`]
        if (stateModel.releaseAfterCapture) {
          parts.push('拍完关闭摄像头')
        }
        if (stateModel.captureInProgress) {
          parts.push('拍摄中...')
        } else if (stateModel.lastCaptureAt) {
          parts.push(`上次: ${formatTime(stateModel.lastCaptureAt)}`)
        }

        return `${baseText} · ${parts.join(' · ')}`
      }

      function render() {
        el.status.textContent = getStatusText()
        el.video.classList.toggle('is-mirrored', stateModel.previewMirrored)
        el.mirrorButton.textContent =
          stateModel.previewMirrored ? '镜像预览: 开 (Space)' : '镜像预览: 关 (Space)'

        const inPip = getPiPElementInPip()
        el.pipButton.textContent = inPip ? '退出画中画 (Enter)' : '进入画中画 (Enter)'

        if (!stateModel.pipSupported) {
          el.pipButton.hidden = true
          return
        }

        el.pipButton.hidden = false

        const stateAllowsPip =
          stateModel.state === State.READY ||
          stateModel.state === State.PIP ||
          (stateModel.state === State.ERROR && Boolean(mediaStream))

        const timedRefreshMode = stateModel.refreshIntervalMs > 0
        const livePipAvailable = stateAllowsPip && stateModel.videoReady && Boolean(mediaStream)
        const canUsePip =
          inPip ||
          (!stateModel.actionLocked &&
            (timedRefreshMode ? supportsCanvasCapture : livePipAvailable))

        el.pipButton.disabled = !canUsePip
      }

      const cameraConstraints = {
        video: {
          facingMode: 'user',
          width: { ideal: 1280 },
          height: { ideal: 720 },
        },
        audio: false,
      }

      let mediaStream = null
      let pipStream = null
      let pipStreamSource = null
      let pipCanvas = null
      let pipContext = null
      let pipFrameRequestId = null
      let snapshotContext = null
      let timedRefreshTimeoutId = null
      let timedRefreshToken = 0
      let requestToken = 0
      const supportsCanvasCapture = typeof HTMLCanvasElement.prototype.captureStream === 'function'
      const useCanvasPipSource = supportsCanvasCapture && !pipCapabilities.webkit

      function shouldUseSnapshotPip() {
        return stateModel.refreshIntervalMs > 0 && supportsCanvasCapture
      }

      function safeCanvasCaptureStream(canvas, frameRate) {
        if (!canvas || typeof canvas.captureStream !== 'function') {
          return null
        }

        if (!Number.isFinite(frameRate) || frameRate <= 0) {
          try {
            return canvas.captureStream()
          } catch (error) {
            return null
          }
        }

        // Safari (and some WebKit builds) may throw when passing a frameRate argument.
        // Fall back to the default captureStream() behavior.
        try {
          return canvas.captureStream(frameRate)
        } catch (error) {
          try {
            return canvas.captureStream()
          } catch (fallbackError) {
            return null
          }
        }
      }

      function getPiPElement() {
        if (shouldUseSnapshotPip()) {
          return el.pipSource
        }
        return useCanvasPipSource ? el.pipSource : el.video
      }

      function getPiPElementInPip() {
        if (pipCapabilities.standard && document.pictureInPictureElement) {
          return (
            document.pictureInPictureElement === el.video ||
            document.pictureInPictureElement === el.pipSource
          )
        }

        return (
          pipCapabilities.webkit &&
          (el.video.webkitPresentationMode === 'picture-in-picture' ||
            el.pipSource.webkitPresentationMode === 'picture-in-picture')
        )
      }

      function isPipSourceInPip() {
        if (pipCapabilities.standard && document.pictureInPictureElement) {
          return document.pictureInPictureElement === el.pipSource
        }

        return (
          pipCapabilities.webkit && el.pipSource.webkitPresentationMode === 'picture-in-picture'
        )
      }

      async function enterPictureInPicture(element) {
        if (
          pipCapabilities.standard &&
          typeof element.requestPictureInPicture === 'function' &&
          document.pictureInPictureEnabled !== false
        ) {
          try {
            await element.requestPictureInPicture()
            return true
          } catch (error) {
            if (!pipCapabilities.webkit || error?.name !== 'NotSupportedError') {
              throw error
            }
          }
        }

        if (
          pipCapabilities.webkit &&
          typeof element.webkitSupportsPresentationMode === 'function' &&
          element.webkitSupportsPresentationMode('picture-in-picture')
        ) {
          element.webkitSetPresentationMode('picture-in-picture')
          return true
        }

        return false
      }

      async function exitPictureInPictureIfActive() {
        if (!getPiPElementInPip()) {
          return
        }

        if (pipCapabilities.standard && document.pictureInPictureElement) {
          await document.exitPictureInPicture()
          return
        }

        if (pipCapabilities.webkit) {
          if (el.video.webkitPresentationMode === 'picture-in-picture') {
            el.video.webkitSetPresentationMode('inline')
          }

          if (el.pipSource.webkitPresentationMode === 'picture-in-picture') {
            el.pipSource.webkitSetPresentationMode('inline')
          }
        }
      }

      function ensurePipCanvasSize(width, height) {
        if (!pipCanvas) {
          pipCanvas = document.createElement('canvas')
          pipContext = pipCanvas.getContext('2d')
        }

        if (!pipContext) {
          return false
        }

        if (pipCanvas.width !== width || pipCanvas.height !== height) {
          pipCanvas.width = width
          pipCanvas.height = height
        }

        return true
      }

      function drawPipFrame() {
        if (!useCanvasPipSource || !pipContext || !pipCanvas || !stateModel.videoReady) {
          return
        }

        const width = pipCanvas.width
        const height = pipCanvas.height

        pipContext.save()
        pipContext.clearRect(0, 0, width, height)

        if (stateModel.previewMirrored) {
          pipContext.translate(width, 0)
          pipContext.scale(-1, 1)
        }

        pipContext.drawImage(el.video, 0, 0, width, height)
        pipContext.restore()
      }

      function stopPipRenderLoop() {
        if (pipFrameRequestId !== null) {
          cancelAnimationFrame(pipFrameRequestId)
          pipFrameRequestId = null
        }
      }

      function startPipRenderLoop() {
        if (pipFrameRequestId !== null || !useCanvasPipSource || pipStreamSource !== 'pipCanvas') {
          return
        }

        const renderNextFrame = () => {
          drawPipFrame()
          pipFrameRequestId = requestAnimationFrame(renderNextFrame)
        }

        pipFrameRequestId = requestAnimationFrame(renderNextFrame)
      }

      function stopPipStream() {
        stopPipRenderLoop()

        if (pipStream) {
          stopTracks(pipStream)
          pipStream = null
        }

        pipStreamSource = null
        el.pipSource.pause()
        el.pipSource.srcObject = null
      }

      async function ensurePipSourceReady() {
        if (shouldUseSnapshotPip()) {
          const canvasReady = ensureSnapshotCanvasSize()
          if (!canvasReady) {
            return false
          }

          if (pipStreamSource !== 'snapshot' || !pipStream || !streamHasLiveTrack(pipStream)) {
            stopPipStream()
            pipStream = safeCanvasCaptureStream(el.snapshot, 30)
            if (!pipStream) {
              return false
            }
            pipStreamSource = 'snapshot'
            el.pipSource.srcObject = pipStream
          }

          if (el.pipSource.readyState < HTMLMediaElement.HAVE_CURRENT_DATA) {
            try {
              await el.pipSource.play()
            } catch (error) {
              return false
            }
          }

          return true
        }

        if (el.video.readyState < HTMLMediaElement.HAVE_CURRENT_DATA) {
          return false
        }

        if (!useCanvasPipSource) {
          return true
        }

        const width = el.video.videoWidth || 1280
        const height = el.video.videoHeight || 720
        const canvasReady = ensurePipCanvasSize(width, height)
        if (!canvasReady) {
          return false
        }

        if (pipStreamSource !== 'pipCanvas' || !pipStream || !streamHasLiveTrack(pipStream)) {
          stopPipStream()
          pipStream = safeCanvasCaptureStream(pipCanvas, 30)
          if (!pipStream) {
            return false
          }
          pipStreamSource = 'pipCanvas'
          el.pipSource.srcObject = pipStream
        }

        drawPipFrame()

        if (el.pipSource.readyState < HTMLMediaElement.HAVE_CURRENT_DATA) {
          try {
            await el.pipSource.play()
          } catch (error) {
            return false
          }
        }

        return true
      }

      function isLocalHost(hostname) {
        return (
          hostname === 'localhost' ||
          hostname === '127.0.0.1' ||
          hostname === '[::1]' ||
          hostname.endsWith('.localhost')
        )
      }

      function isSecureCameraContext() {
        return window.isSecureContext || isLocalHost(window.location.hostname)
      }

      function streamHasLiveTrack(stream) {
        return stream.getTracks().some((track) => track.readyState === 'live')
      }

      function stopTracks(stream) {
        for (const track of stream.getTracks()) {
          track.stop()
        }
      }

      function getSnapshotContext() {
        if (snapshotContext) {
          return snapshotContext
        }
        snapshotContext = el.snapshot.getContext('2d')
        return snapshotContext
      }

      function ensureSnapshotCanvasSize() {
        const ctx = getSnapshotContext()
        if (!ctx) {
          return false
        }

        const rect = el.snapshot.getBoundingClientRect()
        const pixelRatio = window.devicePixelRatio || 1
        const width = Math.max(1, Math.round(rect.width * pixelRatio))
        const height = Math.max(1, Math.round(rect.height * pixelRatio))

        if (el.snapshot.width !== width || el.snapshot.height !== height) {
          el.snapshot.width = width
          el.snapshot.height = height
        }

        return true
      }

      function drawSnapshotFrame() {
        if (!stateModel.videoReady) {
          return
        }

        const ctx = getSnapshotContext()
        if (!ctx) {
          return
        }

        const canvasReady = ensureSnapshotCanvasSize()
        if (!canvasReady) {
          return
        }

        const vw = el.video.videoWidth
        const vh = el.video.videoHeight
        if (!vw || !vh) {
          return
        }

        const cw = el.snapshot.width
        const ch = el.snapshot.height
        const scale = Math.min(cw / vw, ch / vh)
        const dw = vw * scale
        const dh = vh * scale
        const dx = (cw - dw) / 2
        const dy = (ch - dh) / 2

        ctx.save()
        ctx.clearRect(0, 0, cw, ch)

        if (stateModel.previewMirrored) {
          ctx.translate(cw, 0)
          ctx.scale(-1, 1)
          ctx.drawImage(el.video, cw - dx - dw, dy, dw, dh)
        } else {
          ctx.drawImage(el.video, dx, dy, dw, dh)
        }

        ctx.restore()
      }

      function flipSnapshotCanvasHorizontally() {
        const ctx = getSnapshotContext()
        if (!ctx) {
          return
        }

        const cw = el.snapshot.width
        const ch = el.snapshot.height
        if (!cw || !ch) {
          return
        }

        const temp = document.createElement('canvas')
        temp.width = cw
        temp.height = ch
        const tempCtx = temp.getContext('2d')
        if (!tempCtx) {
          return
        }

        tempCtx.drawImage(el.snapshot, 0, 0)

        ctx.save()
        ctx.clearRect(0, 0, cw, ch)
        ctx.translate(cw, 0)
        ctx.scale(-1, 1)
        ctx.drawImage(temp, 0, 0)
        ctx.restore()
      }

      function clearTimedRefreshTimer() {
        if (timedRefreshTimeoutId !== null) {
          clearTimeout(timedRefreshTimeoutId)
          timedRefreshTimeoutId = null
        }
      }

      function stopTimedRefresh({ clearLastFrame = false } = {}) {
        timedRefreshToken++
        clearTimedRefreshTimer()
        stateModel.timedRefreshActive = false
        stateModel.captureInProgress = false
        if (clearLastFrame) {
          stateModel.lastCaptureAt = null
          const ctx = getSnapshotContext()
          if (ctx) {
            ctx.clearRect(0, 0, el.snapshot.width, el.snapshot.height)
          }
        }
        el.app?.classList.remove('is-snapshot-mode')
        render()
      }

      function startTimedRefresh() {
        if (stateModel.refreshIntervalMs <= 0) {
          return
        }

        const token = ++timedRefreshToken
        clearTimedRefreshTimer()
        stateModel.timedRefreshActive = true
        el.app?.classList.add('is-snapshot-mode')
        render()

        const scheduleNext = (delayMs) => {
          if (token !== timedRefreshToken) {
            return
          }
          timedRefreshTimeoutId = window.setTimeout(() => {
            timedRefreshTimeoutId = null
            runTimedRefreshTick(token).catch(() => {
              setState(State.ERROR, { errorCode: ErrorCode.UNKNOWN_ERROR })
            })
          }, delayMs)
        }

        scheduleNext(0)
      }

      function isVideoFrameReady() {
        return (
          stateModel.videoReady &&
          el.video.readyState >= HTMLMediaElement.HAVE_METADATA &&
          el.video.videoWidth > 0 &&
          el.video.videoHeight > 0
        )
      }

      function waitForVideoReady({ timeoutMs = 2500 } = {}) {
        if (isVideoFrameReady()) {
          return Promise.resolve(true)
        }

        return new Promise((resolve) => {
          const timeoutId = window.setTimeout(() => {
            cleanup()
            resolve(false)
          }, timeoutMs)

          let rafId = null

          const check = () => {
            if (isVideoFrameReady()) {
              cleanup()
              resolve(true)
              return
            }
            rafId = requestAnimationFrame(check)
          }

          const cleanup = () => {
            clearTimeout(timeoutId)
            if (rafId !== null) {
              cancelAnimationFrame(rafId)
              rafId = null
            }
            el.video.removeEventListener('loadedmetadata', check)
            el.video.removeEventListener('loadeddata', check)
          }

          el.video.addEventListener('loadedmetadata', check)
          el.video.addEventListener('loadeddata', check)
          rafId = requestAnimationFrame(check)
        })
      }

      async function runTimedRefreshTick(token) {
        if (token !== timedRefreshToken) {
          return
        }

        if (stateModel.refreshIntervalMs <= 0) {
          return
        }

        if (document.visibilityState === 'hidden' && !getPiPElementInPip()) {
          const delay = Math.max(500, stateModel.refreshIntervalMs)
          timedRefreshTimeoutId = window.setTimeout(() => {
            timedRefreshTimeoutId = null
            runTimedRefreshTick(token).catch(() => {
              setState(State.ERROR, { errorCode: ErrorCode.UNKNOWN_ERROR })
            })
          }, delay)
          return
        }

        stateModel.captureInProgress = true
        render()

        try {
          await startCamera()
          const ready = await waitForVideoReady()
          if (!ready || token !== timedRefreshToken) {
            return
          }

          drawSnapshotFrame()
          stateModel.lastCaptureAt = new Date()
        } finally {
          stateModel.captureInProgress = false
          render()
        }

        if (token !== timedRefreshToken) {
          return
        }

        if (stateModel.releaseAfterCapture) {
          await stopCamera({ keepErrorState: true, preservePiP: isPipSourceInPip() })
        }

        timedRefreshTimeoutId = window.setTimeout(() => {
          timedRefreshTimeoutId = null
          runTimedRefreshTick(token).catch(() => {
            setState(State.ERROR, { errorCode: ErrorCode.UNKNOWN_ERROR })
          })
        }, stateModel.refreshIntervalMs)
      }

      function applyRefreshConfig({ intervalMs, releaseAfterCapture }) {
        const normalizedInterval =
          Number.isFinite(intervalMs) ? Math.max(0, Math.trunc(intervalMs)) : 0
        stateModel.refreshIntervalMs = normalizedInterval
        stateModel.releaseAfterCapture = Boolean(releaseAfterCapture)

        el.refreshIntervalInput.value = String(stateModel.refreshIntervalMs)
        el.releaseAfterCaptureInput.checked = stateModel.releaseAfterCapture

        if (stateModel.refreshIntervalMs <= 0) {
          stopTimedRefresh()
          startCamera().catch(() => {
            setState(State.ERROR, { errorCode: ErrorCode.UNKNOWN_ERROR })
          })
          return
        }

        startTimedRefresh()
      }

      function mapGetUserMediaError(error) {
        switch (error?.name) {
          case 'NotAllowedError':
            return ErrorCode.PERMISSION_DENIED
          case 'NotFoundError':
            return ErrorCode.CAMERA_NOT_FOUND
          case 'NotReadableError':
            return ErrorCode.CAMERA_BUSY
          default:
            return ErrorCode.UNKNOWN_ERROR
        }
      }

      function checkPrerequisites() {
        if (!navigator.mediaDevices || typeof navigator.mediaDevices.getUserMedia !== 'function') {
          return { ok: false, errorCode: ErrorCode.NO_MEDIA_DEVICES }
        }

        if (!isSecureCameraContext()) {
          return { ok: false, errorCode: ErrorCode.INSECURE_CONTEXT }
        }

        return { ok: true, errorCode: null }
      }

      async function stopCamera({
        reason = null,
        keepErrorState = false,
        preservePiP = false,
      } = {}) {
        const token = ++requestToken
        setActionLock(false)
        const streamToStop = mediaStream

        if (!preservePiP && getPiPElementInPip()) {
          try {
            await exitPictureInPictureIfActive()
          } catch (error) {
            // Ignore exit errors during shutdown.
          }
        }

        if (token !== requestToken) {
          if (streamToStop && streamToStop !== mediaStream) {
            stopTracks(streamToStop)
          }
          return
        }

        if (streamToStop) {
          stopTracks(streamToStop)
          if (mediaStream === streamToStop) {
            mediaStream = null
          }
        }

        el.video.pause()
        el.video.srcObject = null
        if (!preservePiP && pipStreamSource === 'pipCanvas') {
          stopPipStream()
        }
        setVideoReady(false)

        if (!keepErrorState) {
          setState(State.INIT, { reason })
        }
      }

      async function startCamera() {
        if (stateModel.state === State.LOADING) {
          return
        }

        const precheck = checkPrerequisites()
        if (!precheck.ok) {
          setState(State.ERROR, { errorCode: precheck.errorCode })
          return
        }

        if (mediaStream && streamHasLiveTrack(mediaStream)) {
          setState(getPiPElementInPip() ? State.PIP : State.READY)
          return
        }

        const token = ++requestToken
        setState(State.LOADING)
        setActionLock(true)

        try {
          const stream = await navigator.mediaDevices.getUserMedia(cameraConstraints)

          if (token !== requestToken) {
            stopTracks(stream)
            return
          }

          mediaStream = stream
          el.video.srcObject = stream

          try {
            await el.video.play()
          } catch (error) {
            if (token === requestToken) {
              setState(State.ERROR, { errorCode: ErrorCode.UNKNOWN_ERROR })
            }
            return
          }

          if (token !== requestToken) {
            stopTracks(stream)
            mediaStream = null
            return
          }

          if (el.video.readyState >= HTMLMediaElement.HAVE_CURRENT_DATA) {
            setVideoReady(true)
          }

          setState(State.READY)
        } catch (error) {
          if (token === requestToken) {
            setState(State.ERROR, { errorCode: mapGetUserMediaError(error) })
          }
        } finally {
          if (token === requestToken) {
            setActionLock(false)
          }
        }
      }

      async function togglePictureInPicture() {
        if (stateModel.actionLocked) {
          return
        }

        if (!stateModel.pipSupported) {
          setState(State.ERROR, { errorCode: ErrorCode.PIP_NOT_SUPPORTED })
          return
        }

        const timedRefreshMode = stateModel.refreshIntervalMs > 0
        if (timedRefreshMode && !supportsCanvasCapture) {
          setState(State.ERROR, { errorCode: ErrorCode.CAPTURESTREAM_NOT_SUPPORTED })
          return
        }

        if (!timedRefreshMode && (!stateModel.videoReady || !mediaStream)) {
          setState(State.ERROR, { errorCode: ErrorCode.PIP_NOT_READY })
          return
        }

        setActionLock(true)

        try {
          if (getPiPElementInPip()) {
            await exitPictureInPictureIfActive()
            return
          }

          if (!timedRefreshMode && el.video.readyState < HTMLMediaElement.HAVE_CURRENT_DATA) {
            setState(State.ERROR, { errorCode: ErrorCode.PIP_NOT_READY })
            return
          }

          const pipReady = await ensurePipSourceReady()
          if (!pipReady) {
            setState(State.ERROR, { errorCode: ErrorCode.PIP_FAILED })
            return
          }

          startPipRenderLoop()
          const entered = await enterPictureInPicture(getPiPElement())
          if (!entered) {
            setState(State.ERROR, { errorCode: ErrorCode.PIP_NOT_SUPPORTED })
          }
        } catch (error) {
          setState(State.ERROR, { errorCode: ErrorCode.PIP_FAILED })
        } finally {
          setActionLock(false)
        }
      }

      function toggleMirrorPreview() {
        stateModel.previewMirrored = !stateModel.previewMirrored
        if (getPiPElementInPip() && pipStreamSource === 'pipCanvas') {
          drawPipFrame()
        }
        if (stateModel.timedRefreshActive) {
          if (stateModel.videoReady) {
            drawSnapshotFrame()
          } else {
            flipSnapshotCanvasHorizontally()
          }
        }
        render()
      }

      function isKeyboardInputTarget(target) {
        if (!(target instanceof HTMLElement)) {
          return false
        }

        if (target.isContentEditable) {
          return true
        }

        const tag = target.tagName
        return tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT' || tag === 'BUTTON'
      }

      function bindEvents() {
        el.mirrorButton.addEventListener('click', () => {
          toggleMirrorPreview()
        })

        el.pipButton.addEventListener('click', () => {
          togglePictureInPicture().catch(() => {
            setState(State.ERROR, { errorCode: ErrorCode.PIP_FAILED })
          })
        })

        el.refreshForm.addEventListener('submit', (event) => {
          event.preventDefault()
          const intervalMs = Number.parseInt(el.refreshIntervalInput.value, 10)
          applyRefreshConfig({
            intervalMs: Number.isFinite(intervalMs) ? intervalMs : 0,
            releaseAfterCapture: el.releaseAfterCaptureInput.checked,
          })
        })

        document.addEventListener('keydown', (event) => {
          if (event.repeat || isKeyboardInputTarget(event.target)) {
            return
          }

          if (event.code === 'Space') {
            event.preventDefault()
            toggleMirrorPreview()
            return
          }

          if (event.key === 'Enter') {
            event.preventDefault()
            togglePictureInPicture().catch(() => {
              setState(State.ERROR, { errorCode: ErrorCode.PIP_FAILED })
            })
          }
        })

        el.video.addEventListener('loadeddata', () => {
          setVideoReady(el.video.readyState >= HTMLMediaElement.HAVE_CURRENT_DATA)
        })

        window.addEventListener('resize', () => {
          if (stateModel.timedRefreshActive) {
            drawSnapshotFrame()
          }
        })

        const handleEnterPiP = () => {
          startPipRenderLoop()
          setState(State.PIP)
        }

        const handleLeavePiP = () => {
          stopPipRenderLoop()
          if (document.visibilityState === 'hidden') {
            stopCamera({ reason: 'HIDDEN_RELEASED' }).catch(() => {
              setState(State.ERROR, { errorCode: ErrorCode.UNKNOWN_ERROR })
            })
            return
          }

          if (mediaStream && stateModel.videoReady) {
            setState(State.READY)
            return
          }

          setState(State.INIT)
        }

        el.video.addEventListener('enterpictureinpicture', handleEnterPiP)
        el.video.addEventListener('leavepictureinpicture', handleLeavePiP)
        el.pipSource.addEventListener('enterpictureinpicture', handleEnterPiP)
        el.pipSource.addEventListener('leavepictureinpicture', handleLeavePiP)

        const handleWebkitPresentationModeChange = (targetVideo) => {
          if (targetVideo.webkitPresentationMode === 'picture-in-picture') {
            handleEnterPiP()
            return
          }

          handleLeavePiP()
        }

        el.video.addEventListener('webkitpresentationmodechanged', () => {
          handleWebkitPresentationModeChange(el.video)
        })
        el.pipSource.addEventListener('webkitpresentationmodechanged', () => {
          handleWebkitPresentationModeChange(el.pipSource)
        })

        document.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'hidden') {
            if (getPiPElementInPip()) {
              // Keep stream alive while PiP is active; minimizing window should not close PiP.
              return
            }

            if (stateModel.timedRefreshActive) {
              clearTimedRefreshTimer()
            }

            stopCamera({ reason: 'HIDDEN_RELEASED' }).catch(() => {
              setState(State.ERROR, { errorCode: ErrorCode.UNKNOWN_ERROR })
            })
            return
          }

          if (document.visibilityState === 'visible') {
            if (stateModel.timedRefreshActive) {
              startTimedRefresh()
            } else {
              startCamera().catch(() => {
                setState(State.ERROR, { errorCode: ErrorCode.UNKNOWN_ERROR })
              })
            }
          }
        })

        window.addEventListener('beforeunload', () => {
          stopTimedRefresh()
          if (mediaStream) {
            stopTracks(mediaStream)
            mediaStream = null
          }

          stopPipStream()
        })
      }

      async function bootstrap() {
        try {
          render()
          bindEvents()

          if (!stateModel.pipSupported) {
            setState(State.INIT)
          }

          applyRefreshConfig({
            intervalMs: Number.parseInt(el.refreshIntervalInput.value, 10) || 0,
            releaseAfterCapture: el.releaseAfterCaptureInput.checked,
          })

          if (stateModel.refreshIntervalMs <= 0) {
            await startCamera()
          }
        } catch (error) {
          setState(State.ERROR, { errorCode: ErrorCode.UNKNOWN_ERROR })
        }
      }

      bootstrap().catch(() => {
        setState(State.ERROR, { errorCode: ErrorCode.UNKNOWN_ERROR })
      })
    </script>
  </body>
</html>
